"""Base class for generating OPDS feeds."""
# Standard library imports
from base64 import b64encode
from copy import deepcopy
from datetime import datetime

# Third-party imports
from lxml import etree
from fastapi.responses import Response

# Local application imports
from opds_abs.config import AUDIOBOOKSHELF_API
from opds_abs.utils import dict_to_xml
from opds_abs.utils.error_utils import FeedGenerationError, log_error

class BaseFeedGenerator:
    """Base class for creating OPDS feed components.

    This class provides the foundation for generating OPDS (Open Publication Distribution System)
    feeds for Audiobookshelf content. It includes methods for creating feed structures,
    adding book entries, filtering content, and generating responses.

    Architecture Overview:
    ---------------------
    The OPDS-ABS application uses a hierarchical feed generation system where this base class
    provides common functionality, and specialized subclasses implement specific feed types:

    - LibraryFeedGenerator: Root feed and library items feeds
    - NavigationFeedGenerator: Navigation feeds for different content views
    - SeriesFeedGenerator: Series lists and series item feeds
    - AuthorFeedGenerator: Author listings and author-specific item feeds
    - CollectionFeedGenerator: Collection listings and collection-specific item feeds
    - SearchFeedGenerator: Search results feeds

    Each specialized generator builds on the base functionality to create OPDS-compliant
    XML feeds for different sections of the application. The system is designed to be
    extensible, allowing new feed types to be added easily.

    Components Interaction:
    ---------------------
    1. Feed generators are instantiated in the main.py FastAPI application
    2. Route handlers call specific generator methods based on the requested endpoint
    3. Generators fetch data using the API client and cache mechanisms
    4. XML feeds are built using the helper methods in this base class
    5. Responses are returned to the client in OPDS-compliant format
    """

    def __init__(self):
        """Initialize a new BaseFeedGenerator instance.

        Creates an empty base feed with the appropriate XML namespace declarations
        for OPDS (Open Publication Distribution System) and Atom feeds. This base feed
        serves as the foundation for all feed types generated by derived classes.

        The initialized feed includes:
        - xmlns="http://www.w3.org/2005/Atom" namespace
        - opds="http://opds-spec.org/2010/catalog" namespace mapping
        """
        self.base_feed = etree.Element(
            "feed",
            xmlns="http://www.w3.org/2005/Atom",
            nsmap={"opds": "http://opds-spec.org/2010/catalog"}
        )

    def create_base_feed(self, username=None, library_id=None):
        """Create a copy of the base feed with optional search link.

        Args:
            username (str, optional): Username for personalized feed. Defaults to None.
            library_id (str, optional): Library ID to associate with the feed. Defaults to None.

        Returns:
            Element: An lxml Element object representing the base feed structure.
        """
        base_feed = deepcopy(self.base_feed)
        if username and library_id:
            search_link = {
                "link": {
                    "_attrs": {
                        "href": f"/opds/{username}/libraries/{library_id}/search.xml",
                        "rel": "search",
                        "type": "application/opensearchdescription+xml"
                    }
                }
            }
            dict_to_xml(base_feed, search_link)
        return base_feed

    def create_response(self, feed):
        """Convert feed to XML and create a response.

        Args:
            feed (Element): The lxml Element containing the complete feed.

        Returns:
            Response: A FastAPI Response object with the XML content.
        """
        try:
            feed_xml = etree.tostring(
                    feed,
                    pretty_print=True,
                    xml_declaration=False,
                    encoding="UTF-8"
            )
            return Response(content=feed_xml, media_type="application/atom+xml")
        except Exception as e:
            log_error(e, context="Creating XML response")
            raise FeedGenerationError("Failed to generate XML response") from e

    def add_book_to_feed(self, feed, book, ebook_inos, query_filter="", token=None):
        """Add a book to the feed with all its metadata.

        This method creates an OPDS entry for a book in the feed, including its metadata,
        download links, and cover image. It handles various book formats and ensures
        proper linking with authentication tokens when required.

        Args:
            feed (Element): The lxml Element to add the book entry to.
            book (dict): Dictionary containing book data from Audiobookshelf API.
            ebook_inos (list): List of ebook identifier objects containing ino numbers.
            query_filter (str, optional): Filter string to customize the entry. Defaults to "".
            token (str, optional): Authentication token to use for download links.

        Raises:
            FeedGenerationError: If there's an error adding the book to the feed.

        Example:
            ```python
            # In a feed generator method:
            async def generate_custom_feed(self, username, library_id, token=None):
                # Create the base feed
                feed = self.create_base_feed(username, library_id)

                # Get library items (filtered for ebooks)
                items = await get_cached_library_items(
                    fetch_from_api,
                    self.filter_items,
                    username,
                    library_id,
                    token=token
                )

                # For each book, get its ebook files and add it to the feed
                for book in items:
                    ebook_files = await get_download_urls_from_item(
                        book.get("id", ""),
                        username=username,
                        token=token
                    )

                    # Add the book to the feed
                    self.add_book_to_feed(
                        feed=feed,
                        book=book,
                        ebook_inos=ebook_files,
                        token=token
                    )

                return self.create_response(feed)
            ```
        """
        try:
            media = book.get("media", {})
            # Extract ebook format - check both direct and nested paths (for search results)
            ebook_format = media.get("ebookFormat", media.get("ebookFile", {}).get("ebookFormat"))

            for ebook in ebook_inos:
                book_metadata = media.get("metadata", {})
                book_path = f"{AUDIOBOOKSHELF_API}/items/{book.get('id','')}"

                # Use the token for authentication if available
                auth_param = ""
                if token:
                    auth_param = f"?token={token}"

                download_path = f"{book_path}/file/{ebook.get('ino')}/download{auth_param}"
                # Cover URL doesn't need authentication
                cover_url = f"{book_path}/cover?format=jpeg"
                series_list = book_metadata.get("seriesName", None)
                added_at = datetime.fromtimestamp(book.get('addedAt')/1000).strftime('%Y-%m-%d')

                # Create the description content with HTML formatting
                content_text = (
                    f"{book_metadata.get('description', '')}<br/><br/>"
                    f"{'Series: ' + series_list + '<br/>' if series_list else ''}"
                    f"Published year: {book_metadata.get('publishedYear')}<br/>"
                    f"Genres: {', '.join(book_metadata.get('genres', []))}<br/>"
                    f"Added at: {added_at}<br/>"
                )

                # Build the entry data structure
                entry_data = {
                    "entry": {
                        "title": {"_text": book_metadata.get("title", "Unknown Title")},
                        "id": {"_text": book.get("id")},
                        "content": {
                            "_attrs": {"type": "xhtml"},
                            "_text": content_text
                        },
                        "author": {
                            "name": {"_text": book_metadata.get("authorName", "Unknown Author")}
                        },
                        "link": [
                            {
                                "_attrs": {
                                    "href": download_path,
                                    "rel": "http://opds-spec.org/acquisition",
                                    "type": f"application/{ebook_format or 'epub'}+zip"
                                }
                            },
                            {
                                "_attrs": {
                                    "href": cover_url,
                                    "rel": "http://opds-spec.org/image",
                                    "type": "image/jpeg"
                                }
                            }
                        ]
                    }
                }

                # Add series info if filtering by series
                if query_filter.startswith("series"):
                    series_number = book_metadata.get('series', {}).get("sequence", "")
                    series_name = book_metadata.get('series', {}).get("name", "")
                    entry_data["entry"]["series"] = {
                        "name": {"_text": f" - {series_name} #{series_number}"}
                    }

                # Convert the dictionary to XML elements
                dict_to_xml(feed, entry_data)

        except (ValueError, KeyError) as e:
            book_title = book.get("media", {}).get("metadata", {}).get("title", "Unknown")
            context = f"Adding book '{book_title}' to feed"
            log_error(e, context=context)
            raise FeedGenerationError(f"Failed to add book to feed: {str(e)}") from e
        except Exception as e:
            book_title = book.get("media", {}).get("metadata", {}).get("title", "Unknown")
            context = f"Adding book '{book_title}' to feed"
            log_error(e, context=context)
            raise FeedGenerationError(f"Unexpected error adding book to feed: {str(e)}") from e

    def create_filter(self, abs_filter=None):
        """Create a base64-encoded filter to be used by Audiobookshelf.

        Args:
            abs_filter (str, optional): Filter string to encode. Defaults to None.

        Returns:
            str: Base64-encoded filter string.
        """
        try:
            if abs_filter is None:
                return ""
            return b64encode(abs_filter.encode("utf-8")).decode("utf-8")
        except Exception as e:
            log_error(e, context="Creating base64 filter")
            # Return empty string on error rather than raising exception
            # since this is a utility function
            return ""

    def filter_items(self, data):
        """Find items in a library that have an ebook file, sorted by a field in a specific order.

        Args:
            data (dict): The data containing items to filter.

        Returns:
            list: Filtered list of items that have ebook files.

        Raises:
            FeedGenerationError: If there's an error filtering the items.
        """
        try:
            n = 1
            filtered_results = []
            for result in data.get("results", []):
                media = result.get("media", {})
                if "ebookFormat" in media and media.get("ebookFormat", None):
                    result.update({"opds_seq":n})
                    n += 1
                    filtered_results.append(result)

            return filtered_results
        except Exception as e:
            log_error(e, context="Filtering items for ebooks")
            raise FeedGenerationError(f"Error filtering items: {str(e)}") from e

    def sort_results(self, data):
        """Sort results based on the opds_seq field.

        Args:
            data (list): List of items to sort.

        Returns:
            list: Sorted list of items.

        Raises:
            FeedGenerationError: If there's an error sorting the results.
        """
        try:
            sorted_results = sorted(
                    data,
                    key=lambda x: x["opds_seq"],
                    reverse=False
                )
            return sorted_results
        except Exception as e:
            log_error(e, context="Sorting results")
            raise FeedGenerationError(f"Error sorting results: {str(e)}") from e

    def extract_value(self, item, path):
        """Extract value from a nested dictionary using a dot-separated path.

        Args:
            item (dict): The dictionary to extract values from.
            path (str): Dot-separated path indicating where to find the value.

        Returns:
            any: The extracted value, or None if the path doesn't exist.
        """
        try:
            keys = path.split('.')
            for key in keys:
                item = item.get(key, None)
                if item is None:
                    break
            return item
        except Exception as e:
            # Just log here but don't raise as this is a utility function
            log_error(e, context=f"Extracting value from path {path}")
            return None
